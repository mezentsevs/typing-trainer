Следующая задача. Сейчас, если текста достаточно много, он выводится сразу полностью. Нужно сделать так, чтобы максимально в один момент времени отображалось только четыре строки, а если кода больше, то область вывода текста должна автоматически прокручиваться, согласно текущим символам, которые вводит в данный момент пользователь. Выведи обновленный код компонентов.




Чтобы ограничить отображение текста до четырех строк и добавить автоматическую прокрутку в зависимости от текущей позиции ввода пользователя в компонентах Lesson.vue и FinalTest.vue, внесем следующие изменения:

Добавим фиксированную высоту для области текста, эквивалентную четырем строкам, используя Tailwind CSS (h-16 или аналог, в зависимости от размера шрифта, который составляет text-lg, то есть примерно 1.125rem). Для точного расчета высоты: 1.125rem * 1.5 (межстрочный интервал по умолчанию) * 4 строки ≈ 6.75rem, что соответствует h-28 в Tailwind.
Применим overflow-y-auto для включения вертикальной прокрутки, если текст превышает высоту.
Добавим динамическую прокрутку, используя реф на контейнер текста и метод для прокрутки к текущему символу на основе typed.value.length.
Используем scrollTo для плавной прокрутки, чтобы текущий символ был виден в области просмотра.
Минимальные изменения будут включать добавление рефа для контейнера текста, обновление шаблона с Tailwind-классами и добавление логики прокрутки в handleInput.

vue

Копировать
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Lesson {{ lesson.number }}</h2>
                <span v-if="isLessonCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <NewCharacters :new-chars="lesson.new_chars" />
            <Statistics :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char }">
                        {{ char }}
                    </span>
                </div>
                <input
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4"
                    ref="input"
                    autofocus
                    :disabled="isLessonCompleted"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
            </div>
            <router-link
                v-if="nextLesson && isLessonCompleted"
                :to="`/lesson/${language}/${nextLesson.number}`"
                @click="resetAndLoadNext"
                class="mt-4 inline-block bg-blue-500 text-white p-2 rounded"
            >
                Next Lesson
            </router-link>
            <router-link
                v-else-if="isLessonCompleted"
                :to="`/test/${language}`"
                class="mt-4 inline-block bg-green-500 text-white p-2 rounded"
            >
                Take Final Test
            </router-link>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import NewCharacters from './NewCharacters.vue';

const route = useRoute();
const language = route.params.language as string;
const lessonNumber = ref(parseInt(route.params.number as string));
const lesson = ref<{ id: number; number: number; new_chars: string }>({ id: 0, number: lessonNumber.value, new_chars: '' });
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLInputElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const lessons = ref<any[]>([]);
const isLessonCompleted = ref(false);

const nextLesson = computed(() => lessons.value.find(l => l.number === lessonNumber.value + 1));
const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const resetState = () => {
    text.value = '';
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isLessonCompleted.value = false;
};

const fetchLesson = async () => {
    const [lessonsRes, textRes] = await Promise.all([
        axios.get(`/lessons/${language}`),
        axios.get(`/lessons/${language}/${lessonNumber.value}/text`),
    ]);

    lessons.value = lessonsRes.data;
    lesson.value = lessonsRes.data.find((l: any) => l.number === lessonNumber.value);
    text.value = textRes.data.text;
};

const scrollToCurrentChar = () => {
    if (!textContainer.value) return;
    const currentIndex = typed.value.length;
    const charElements = textContainer.value.querySelectorAll('span');
    if (charElements[currentIndex]) {
        const charRect = charElements[currentIndex].getBoundingClientRect();
        const containerRect = textContainer.value.getBoundingClientRect();
        const offset = charRect.top - containerRect.top + textContainer.value.scrollTop;
        textContainer.value.scrollTo({ top: offset - containerRect.height / 2, behavior: 'smooth' });
    }
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isLessonCompleted.value = true;
        await axios.post('/lessons/progress', {
            lesson_id: lesson.value.id,
            language: language,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar();
};

const resetAndLoadNext = async () => {
    if (!isLessonCompleted.value) return;
    lessonNumber.value++;
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
};

onMounted(async () => {
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
});
</script>
Показать в боковой панели
vue

Копировать
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Final Test</h2>
                <span v-if="isTestCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <FinalTestSetup v-if="!text" :upload-file="uploadFile" @start-test="fetchText" />
            <Statistics v-if="text" :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div v-if="text" class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char }">
                        {{ char }}
                    </span>
                </div>
                <input v-model="typed" @input="handleInput" class="w-full p-2 border rounded mt-4" ref="input" :disabled="isTestCompleted" autofocus />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <router-link v-if="isTestCompleted" to="/" class="bg-blue-500 text-white p-2 rounded mt-2 inline-block">Back to Home</router-link>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import FinalTestSetup from './FinalTestSetup.vue';

const route = useRoute();
const language = ref(route.params.language as string);
const genre = ref('');
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLInputElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const isTestCompleted = ref(false);

const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const fetchText = async () => {
    const response = await axios.get('/test/text', { params: { language: language.value, genre: genre.value } });
    text.value = response.data.text;
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isTestCompleted.value = false;
};

const uploadFile = async (event: Event) => {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('language', language.value);
        await axios.post('/test/upload', formData);
        await fetchText();
    }
};

const scrollToCurrentChar = () => {
    if (!textContainer.value) return;
    const currentIndex = typed.value.length;
    const charElements = textContainer.value.querySelectorAll('span');
    if (charElements[currentIndex]) {
        const charRect = charElements[currentIndex].getBoundingClientRect();
        const containerRect = textContainer.value.getBoundingClientRect();
        const offset = charRect.top - containerRect.top + textContainer.value.scrollTop;
        textContainer.value.scrollTo({ top: offset - containerRect.height / 2, behavior: 'smooth' });
    }
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isTestCompleted.value = true;
        await axios.post('/test/result', {
            language: language.value,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar();
};

onMounted(() => {
    if (input.value) {
        input.value.focus();
    }
});
</script>
Показать в боковой панели






Нужно сделать рефакторинг полученного результата. Вынеси функцию scrollToCurrentChar в отдельный файл, и используй ее в обоих компонентах. Без дублирования кода. Минимальные изменения. Выведи код нового файла и обновленный код обоих компонентов.




Чтобы выполнить рефакторинг и устранить дублирование кода, вынесем функцию scrollToCurrentChar в отдельный файл utils.ts и импортируем её в компоненты Lesson.vue и FinalTest.vue. Изменения будут минимальными: добавим новый файл и обновим компоненты, заменив определение функции импортом. Остальной код останется без изменений.

typescript

Копировать
export const scrollToCurrentChar = (textContainer: HTMLElement | null, typedLength: number) => {
    if (!textContainer) return;
    const currentIndex = typedLength;
    const charElements = textContainer.querySelectorAll('span');
    if (charElements[currentIndex]) {
        const charRect = charElements[currentIndex].getBoundingClientRect();
        const containerRect = textContainer.getBoundingClientRect();
        const offset = charRect.top - containerRect.top + textContainer.scrollTop;
        textContainer.scrollTo({ top: offset - containerRect.height / 2, behavior: 'smooth' });
    }
};
Показать в боковой панели
vue

Копировать
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Lesson {{ lesson.number }}</h2>
                <span v-if="isLessonCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <NewCharacters :new-chars="lesson.new_chars" />
            <Statistics :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char }">
                        {{ char }}
                    </span>
                </div>
                <input
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4"
                    ref="input"
                    autofocus
                    :disabled="isLessonCompleted"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
            </div>
            <router-link
                v-if="nextLesson && isLessonCompleted"
                :to="`/lesson/${language}/${nextLesson.number}`"
                @click="resetAndLoadNext"
                class="mt-4 inline-block bg-blue-500 text-white p-2 rounded"
            >
                Next Lesson
            </router-link>
            <router-link
                v-else-if="isLessonCompleted"
                :to="`/test/${language}`"
                class="mt-4 inline-block bg-green-500 text-white p-2 rounded"
            >
                Take Final Test
            </router-link>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import NewCharacters from './NewCharacters.vue';
import { scrollToCurrentChar } from '../utils';

const route = useRoute();
const language = route.params.language as string;
const lessonNumber = ref(parseInt(route.params.number as string));
const lesson = ref<{ id: number; number: number; new_chars: string }>({ id: 0, number: lessonNumber.value, new_chars: '' });
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLInputElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const lessons = ref<any[]>([]);
const isLessonCompleted = ref(false);

const nextLesson = computed(() => lessons.value.find(l => l.number === lessonNumber.value + 1));
const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const resetState = () => {
    text.value = '';
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isLessonCompleted.value = false;
};

const fetchLesson = async () => {
    const [lessonsRes, textRes] = await Promise.all([
        axios.get(`/lessons/${language}`),
        axios.get(`/lessons/${language}/${lessonNumber.value}/text`),
    ]);

    lessons.value = lessonsRes.data;
    lesson.value = lessonsRes.data.find((l: any) => l.number === lessonNumber.value);
    text.value = textRes.data.text;
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isLessonCompleted.value = true;
        await axios.post('/lessons/progress', {
            lesson_id: lesson.value.id,
            language: language,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

const resetAndLoadNext = async () => {
    if (!isLessonCompleted.value) return;
    lessonNumber.value++;
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
};

onMounted(async () => {
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
});
</script>
Показать в боковой панели
vue

Копировать
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Final Test</h2>
                <span v-if="isTestCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <FinalTestSetup v-if="!text" :upload-file="uploadFile" @start-test="fetchText" />
            <Statistics v-if="text" :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div v-if="text" class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char }">
                        {{ char }}
                    </span>
                </div>
                <input v-model="typed" @input="handleInput" class="w-full p-2 border rounded mt-4" ref="input" :disabled="isTestCompleted" autofocus />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <router-link v-if="isTestCompleted" to="/" class="bg-blue-500 text-white p-2 rounded mt-2 inline-block">Back to Home</router-link>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import FinalTestSetup from './FinalTestSetup.vue';
import { scrollToCurrentChar } from '../utils';

const route = useRoute();
const language = ref(route.params.language as string);
const genre = ref('');
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLInputElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const isTestCompleted = ref(false);

const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const fetchText = async () => {
    const response = await axios.get('/test/text', { params: { language: language.value, genre: genre.value } });
    text.value = response.data.text;
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isTestCompleted.value = false;
};

const uploadFile = async (event: Event) => {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('language', language.value);
        await axios.post('/test/upload', formData);
        await fetchText();
    }
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isTestCompleted.value = true;
        await axios.post('/test/result', {
            language: language.value,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

onMounted(() => {
    if (input.value) {
        input.value.focus();
    }
});
</script>
Показать в боковой панели





Чем я могу помочь?


DeepSearch


Think

Grok 3