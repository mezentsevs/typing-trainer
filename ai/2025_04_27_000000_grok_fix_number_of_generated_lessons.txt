В веб приложении для тренировки навыка печати слепым методом генерируются уроки. Предоставляю контекстные данные для выполнения задачи:
app/Http/Controllers/LessonController.php
<?php

namespace App\Http\Controllers;

use App\Models\Lesson;
use App\Models\LessonProgress;
use App\Services\LessonService;
use Illuminate\Http\Request;

class LessonController extends Controller
{
    protected $lessonService;

    public function __construct(LessonService $lessonService)
    {
        $this->lessonService = $lessonService;
    }

    public function generate(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'lesson_count' => 'required|integer|min:1',
        ]);

        $this->lessonService->generateLessons($request->language, $request->lesson_count, auth()->id());

        return response()->json(['message' => 'Lessons generated']);
    }

    public function index(string $language)
    {
        $lessons = Lesson::where('language', $language)->where('user_id', auth()->id())->get();
        return response()->json($lessons);
    }

    public function getText(string $language, int $lessonNumber)
    {
        $text = $this->lessonService->generateLessonText($language, $lessonNumber, auth()->id());
        return response()->json(['text' => $text]);
    }

    public function saveProgress(Request $request)
    {
        $request->validate([
            'lesson_id' => 'required|exists:lessons,id',
            'language' => 'required|string',
            'time_seconds' => 'required|integer',
            'speed_wpm' => 'required|integer',
            'errors' => 'required|integer',
        ]);

        $progress = LessonProgress::create([
            'user_id' => auth()->id(),
            'lesson_id' => $request->lesson_id,
            'language' => $request->language,
            'time_seconds' => $request->time_seconds,
            'speed_wpm' => $request->speed_wpm,
            'errors' => $request->errors,
        ]);

        return response()->json($progress);
    }
}
app/Services/LessonService.php
<?php

namespace App\Services;

use App\Models\Lesson;

class LessonService
{
    protected $introductionOrder = [
        'en' => [
            'a', 's', 'd', 'f', 'j', 'k', 'l', ';',
            'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
            'h', 'g', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',
            'A', 'S', 'D', 'F', 'J', 'K', 'L', ';',
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
            'H', 'G', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '\\', ':', '"', '\'', '<', '>', '?', '~', '`'
        ],
        'ru' => [
            'ф', 'ы', 'в', 'а', 'о', 'л', 'д', 'ж',
            'й', 'ц', 'у', 'к', 'е', 'н', 'г', 'ш', 'щ', 'з', 'х', 'ъ',
            'я', 'ч', 'с', 'м', 'и', 'т', 'ь', 'б', 'ю', 'п', 'р', 'э',
            'ё',
            'Ф', 'Ы', 'В', 'А', 'О', 'Л', 'Д', 'Ж',
            'Й', 'Ц', 'У', 'К', 'Е', 'Н', 'Г', 'Ш', 'Щ', 'З', 'Х', 'Ъ',
            'Я', 'Ч', 'С', 'М', 'И', 'Т', 'Ь', 'Б', 'Ю', 'П', 'Р', 'Э',
            'Ё',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '"', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '/', ',', '.', '<', '>', '?', ':', ';'
        ],
    ];

    protected $pairedMap = [
        '(' => ')',
        '[' => ']',
        '{' => '}',
        '<' => '>',
        '"' => '"',
        "'" => "'",
        '`' => '`'
    ];

    protected $minLessonLength = 100;
    protected $maxLessonLength = 1000;
    protected $minWordsPerLine = 2;
    protected $maxWordsPerLine = 8;

    public function generateLessons(string $language, int $lessonCount, int $userId): void
    {
        $chars = $this->introductionOrder[$language] ?? $this->introductionOrder['en'];
        $charsPerLesson = ceil(count($chars) / $lessonCount);

        Lesson::where('language', $language)->where('user_id', $userId)->delete();

        for ($i = 0; $i < $lessonCount; $i++) {
            $start = $i * $charsPerLesson;
            $newChars = array_slice($chars, $start, $charsPerLesson);
            if ($newChars) {
                Lesson::create([
                    'user_id' => $userId,
                    'number' => $i + 1,
                    'language' => $language,
                    'new_chars' => implode('', $newChars),
                ]);
            }
        }
    }

    public function generateLessonText(string $language, int $lessonNumber, int $userId, ?int $length = null): string
    {
        $availableChars = '';
        $newChars = '';

        $lessons = Lesson::where('language', $language)->where('user_id', $userId)->where('number', '<=', $lessonNumber)->get();
        foreach ($lessons as $lesson) {
            $availableChars .= $lesson->new_chars;
            if ($lesson->number == $lessonNumber) {
                $newChars = $lesson->new_chars;
            }
        }

        $availableCharsArray = mb_str_split($availableChars, 1, 'UTF-8');
        $newCharsArray = mb_str_split($newChars, 1, 'UTF-8');

        if (empty($availableCharsArray)) {
            return '';
        }

        $totalLessons = Lesson::where('language', $language)->where('user_id', $userId)->max('number') ?? 1;
        if ($length === null) {
            if ($totalLessons <= 1) {
                $length = $this->minLessonLength;
            } else {
                $length = $this->minLessonLength + ($this->maxLessonLength - $this->minLessonLength) * ($lessonNumber - 1) / ($totalLessons - 1);
            }
        }

        $text = '';
        $wordsAdded = 0;
        $lineWordCount = 0;
        $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
        $isFirstOfPair = true;
        $baseWord = null;

        while (mb_strlen($text) < $length) {
            if ($wordsAdded > 0) {
                if ($lineWordCount >= $currentLineWords) {
                    $separator = "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                } else {
                    $separator = " ";
                }
                if (mb_strlen($text) + mb_strlen($separator) > $length) {
                    break;
                }
                $text .= $separator;
            }

            if ($isFirstOfPair) {
                $baseWord = $this->generateEnhancedWord($availableCharsArray, $newCharsArray, $language);
                $currentWord = $baseWord;
                $isFirstOfPair = false;

                $remainingAfterFirst = $length - mb_strlen($text) - mb_strlen($currentWord);
                if ($wordsAdded > 0) {
                    $remainingAfterFirst -= mb_strlen($separator);
                }
                $remainingAfterSecond = $remainingAfterFirst - mb_strlen(" ") - mb_strlen($currentWord);

                if ($remainingAfterFirst < 0 || $remainingAfterSecond < 0) {
                    break;
                }

                if ($lineWordCount + 2 > $currentLineWords) {
                    $text .= "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                }
            } else {
                $currentWord = $baseWord;
                $isFirstOfPair = true;
            }

            $remaining = $length - mb_strlen($text);
            if (mb_strlen($currentWord) > $remaining) {
                $currentWord = mb_substr($currentWord, 0, $remaining);
            }

            $text .= $currentWord;

            if (mb_strlen($currentWord) >= 3) {
                $wordsAdded++;
                $lineWordCount++;
            }
        }

        $lines = explode("\n", $text);
        $lines = array_map('rtrim', $lines);
        $text = implode("\n", $lines);

        return mb_substr($text, 0, $length);
    }

    private function generateEnhancedWord(array $availableCharsArray, array $newCharsArray, string $language): string
    {
        $availableLetters = array_filter($availableCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $newLetters = array_filter($newCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $allVowels = $this->getVowels($language);
        $availableVowels = array_intersect($allVowels, $availableLetters);
        $newVowels = array_intersect($allVowels, $newLetters);

        $allConsonants = $this->getConsonants($language);
        $availableConsonants = array_intersect($allConsonants, $availableLetters);
        $newConsonants = array_intersect($allConsonants, $newLetters);

        $availableNumbers = array_filter($availableLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $newNumbers = array_filter($newLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $wordLength = random_int(3, 8);
        $letterPart = '';

        if (!empty($availableVowels) && !empty($availableConsonants)) {
            $startType = rand(0, 1) == 0 ? 'V' : 'C';
            $startSet = $startType == 'V' ? $availableVowels : $availableConsonants;
            $startSetNew = $startType == 'V' ? $newVowels : $newConsonants;
            $otherSet = $startType == 'V' ? $availableConsonants : $availableVowels;
            $otherSetNew = $startType == 'V' ? $newConsonants : $newVowels;
        } elseif (!empty($availableVowels)) {
            $startSet = $availableVowels;
            $startSetNew = $newVowels;
            $otherSet = [];
            $otherSetNew = [];
        } elseif (!empty($availableConsonants)) {
            $startSet = $availableConsonants;
            $startSetNew = $newConsonants;
            $otherSet = [];
            $otherSetNew = [];
        } else {
            return '';
        }

        for ($i = 0; $i < $wordLength; $i++) {
            $set = ($i % 2 == 0) ? $startSet : $otherSet;
            $setNew = ($i % 2 == 0) ? $startSetNew : $otherSetNew;

            if (empty($set)) {
                $set = $availableLetters;
                $setNew = $newLetters;
            }

            $useNumber = !empty($availableNumbers) && rand(0, 99) < 30;
            if ($useNumber) {
                if (!empty($newNumbers) && rand(0, 99) < 70) {
                    $letterPart .= $newNumbers[array_rand($newNumbers)];
                } else {
                    $letterPart .= $availableNumbers[array_rand($availableNumbers)];
                }
            } else {
                if (!empty($setNew) && rand(0, 99) < 70) {
                    $letterPart .= $setNew[array_rand($setNew)];
                } else {
                    $letterPart .= $set[array_rand($set)];
                }
            }
        }

        $availableSpecials = array_filter($availableCharsArray, function ($char) {
            return !preg_match('/[a-zA-Z0-9а-яА-ЯёЁ]/u', $char);
        });

        $pairedSymbols = array_merge(array_keys($this->pairedMap), array_values($this->pairedMap));
        $singleSpecials = array_diff($availableSpecials, $pairedSymbols);

        $possiblePairedOpenings = ['(', '[', '{', '<', '"', "'", '`'];
        $availablePairedOpenings = array_intersect($possiblePairedOpenings, $availableSpecials);
        $availablePaired = [];

        foreach ($availablePairedOpenings as $opening) {
            if (in_array($this->pairedMap[$opening], $availableSpecials)) {
                $availablePaired[] = $opening;
            }
        }

        $totalOptions = ['none'];
        if (!empty($singleSpecials)) {
            $totalOptions[] = 'single';
        }
        if (!empty($availablePaired)) {
            $totalOptions[] = 'paired';
        }

        $type = $totalOptions[array_rand($totalOptions)];

        if ($type == 'none') {
            return $letterPart;
        } elseif ($type == 'single') {
            $special = $singleSpecials[array_rand($singleSpecials)];
            if ($this->isPunctuation($special)) {
                return $letterPart . $special;
            }
            $position = rand(0, 1) == 0 ? 'start' : 'end';
            return $position == 'start' ? $special . $letterPart : $letterPart . $special;
        } else {
            $opening = $availablePaired[array_rand($availablePaired)];
            $closing = $this->pairedMap[$opening];
            return $opening . $letterPart . $closing;
        }
    }

    private function isPunctuation(string $char): bool
    {
        return in_array($char, [',', '.', ';', ':', '!', '?']);
    }

    private function getVowels(string $language): array
    {
        if ($language == 'ru') {
            return ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я', 'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я'];
        } elseif ($language == 'en') {
            return ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];
        }
        return [];
    }

    private function getConsonants(string $language): array
    {
        if ($language == 'ru') {
            return array_diff($this->getRussianLetters(), $this->getVowels('ru'));
        } elseif ($language == 'en') {
            return array_diff($this->getEnglishLetters(), $this->getVowels('en'));
        }
        return [];
    }

    private function getRussianLetters(): array
    {
        return array_merge(
            ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я'],
            ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я']
        );
    }

    private function getEnglishLetters(): array
    {
        return array_merge(
            range('a', 'z'),
            range('A', 'Z')
        );
    }
}
routes/api.php
<?php

use App\Http\Controllers\AuthController;
use App\Http\Controllers\LessonController;
use App\Http\Controllers\TestController;
use Illuminate\Support\Facades\Route;

Route::post('/register', [AuthController::class, 'register']);
Route::post('/login', [AuthController::class, 'login']);

Route::middleware('auth:sanctum')->group(function () {
    Route::post('/logout', [AuthController::class, 'logout']);

    Route::prefix('lessons')->group(function () {
        Route::post('/generate', [LessonController::class, 'generate']);
        Route::get('/{language}', [LessonController::class, 'index']);
        Route::get('/{language}/{lessonNumber}/text', [LessonController::class, 'getText']);
        Route::post('/progress', [LessonController::class, 'saveProgress']);
    });

    Route::prefix('test')->group(function () {
        Route::get('/text', [TestController::class, 'getTestText']);
        Route::post('/upload', [TestController::class, 'uploadText']);
        Route::post('/result', [TestController::class, 'saveResult']);
    });
});
resources/js/router/index.ts
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/components/Home.vue';
import Login from '@/components/Login.vue';
import Register from '@/components/Register.vue';
import LessonSetup from '@/components/LessonSetup.vue';
import Lesson from '@/components/Lesson.vue';
import FinalTest from '@/components/FinalTest.vue';

const routes = [
    { path: '/', component: Home, meta: { requiresAuth: true } },
    { path: '/login', component: Login },
    { path: '/register', component: Register },
    { path: '/setup', component: LessonSetup, meta: { requiresAuth: true } },
    { path: '/lesson/:language/:number', component: Lesson, meta: { requiresAuth: true } },
    { path: '/test/:language', component: FinalTest, meta: { requiresAuth: true } },
];

const router = createRouter({
    history: createWebHistory(),
    routes,
});

router.beforeEach((to, from, next) => {
    const token = localStorage.getItem('token');
    if (to.meta.requiresAuth && !token) {
        next('/login');
    } else {
        next();
    }
});

export default router;
resources/js/components/LessonSetup.vue
<template>
    <div class="min-h-screen flex items-center justify-center bg-gray-100">
        <div class="bg-white p-8 rounded shadow-md w-full max-w-md">
            <h2 class="text-2xl font-bold mb-6">Setup Lessons</h2>
            <form @submit.prevent="generateLessons">
                <div class="mb-4">
                    <label class="block text-gray-700">Language</label>
                    <select v-model="form.language" class="w-full p-2 border rounded" required>
                        <option value="en">English</option>
                        <option value="ru">Russian</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700">Number of Lessons</label>
                    <input v-model.number="form.lesson_count" type="number" min="1" class="w-full p-2 border rounded" required />
                </div>
                <button type="submit" class="w-full bg-blue-500 text-white p-2 rounded">Generate Lessons</button>
            </form>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import axios from 'axios';

const router = useRouter();
const form = ref({ language: 'en', lesson_count: 10 });

const generateLessons = async () => {
    try {
        await axios.post('/lessons/generate', form.value);
        router.push(`/lesson/${form.value.language}/1`);
    } catch (error) {
        alert('Failed to generate lessons');
    }
};
</script>
resources/js/components/Lesson.vue
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Lesson {{ lesson.number }}/{{ totalLessons }}</h2>
                <span v-if="isLessonCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <div class="flex flex-row items-stretch space-x-4 mb-4">
                <NewCharacters :new-chars="lesson.new_chars" class="flex items-center justify-center" />
                <Statistics :language :time :speed :errors :progress />
            </div>
            <div class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto bg-gray-50 p-2">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char, 'current-word': isCurrentWord[index], 'space': char === ' ', 'line-break': char === '\n' }">
                        {{ char }}
                    </span>
                </div>
                <textarea
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4 resize-none"
                    ref="input"
                    autofocus
                    :disabled="isLessonCompleted"
                    rows="4"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <div v-if="isLessonCompleted" class="flex justify-center mt-4">
                    <router-link
                        v-if="nextLesson"
                        :to="`/lesson/${language}/${nextLesson.number}`"
                        @click="resetAndLoadNext"
                        class="bg-blue-500 text-white p-2 rounded"
                    >
                        Next Lesson
                    </router-link>
                    <router-link
                        v-else
                        :to="`/test/${language}`"
                        class="bg-green-500 text-white p-2 rounded"
                    >
                        Take Final Test
                    </router-link>
                </div>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import NewCharacters from './NewCharacters.vue';
import { scrollToCurrentChar } from '@/helpers/DomHelper';
import { getCurrentTypingUnit } from '@/helpers/StringHelper';

const route = useRoute();
const language = route.params.language as string;
const lessonNumber = ref(parseInt(route.params.number as string));
const lesson = ref<{ id: number; number: number; new_chars: string }>({ id: 0, number: lessonNumber.value, new_chars: '' });
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLTextAreaElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const lessons = ref<any[]>([]);
const isLessonCompleted = ref(false);
const totalLessons = ref(0);

const nextLesson = computed(() => lessons.value.find(l => l.number === lessonNumber.value + 1));
const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const resetState = () => {
    text.value = '';
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isLessonCompleted.value = false;
};

const fetchLesson = async () => {
    const [lessonsRes, textRes] = await Promise.all([
        axios.get(`/lessons/${language}`),
        axios.get(`/lessons/${language}/${lessonNumber.value}/text`),
    ]);

    lessons.value = lessonsRes.data;
    totalLessons.value = lessonsRes.data.length;
    lesson.value = lessonsRes.data.find((l: any) => l.number === lessonNumber.value);
    text.value = textRes.data.text;
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isLessonCompleted.value = true;
        await axios.post('/lessons/progress', {
            lesson_id: lesson.value.id,
            language: language,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

const resetAndLoadNext = async () => {
    if (!isLessonCompleted.value) return;
    lessonNumber.value++;
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
};

onMounted(async () => {
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
});

const currentTypingUnit = computed(() => getCurrentTypingUnit(text.value, typed.value.length));

const isCurrentWord = computed(() => {
    const range = currentTypingUnit.value;
    if (!range) return Array(text.value.length).fill(false);
    const arr = Array(text.value.length).fill(false);
    for (let i = range.start; i <= range.end; i++) {
        arr[i] = true;
    }
    return arr;
});
</script>
Сейчас, я заметил, что иногда при выборе количества уроков для генерации создается уроков меньше, чем задал пользователь. Например, я выбрал, чтобы сгенерировалось 15 уроков, а на самом деле сгенерировалось всего 14 уроков, и при этом в базе данных было всего 14 уроков вместо заданных пользователем 15. Нужно это исправить с минимальными изменениями в коде без добавления новых комментариев. Выведи полный обновленный код всех измененных файлов.




Проблема заключается в методе generateLessons в LessonService.php. При делении символов на уроки используется ceil(count($chars) / $lessonCount), что может привести к созданию меньшего количества уроков, если символов недостаточно для равномерного распределения. Чтобы гарантировать создание ровно $lessonCount уроков, нужно изменить логику так, чтобы всегда создавалось указанное количество уроков, даже если последние уроки будут содержать меньше символов или повторять их.

Ниже приведен обновленный код файла app/Services/LessonService.php с минимальными изменениями, решающими проблему.

app/Services/LessonService.php

php

Копировать
<?php

namespace App\Services;

use App\Models\Lesson;

class LessonService
{
    protected $introductionOrder = [
        'en' => [
            'a', 's', 'd', 'f', 'j', 'k', 'l', ';',
            'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
            'h', 'g', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',
            'A', 'S', 'D', 'F', 'J', 'K', 'L', ';',
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
            'H', 'G', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '\\', ':', '"', '\'', '<', '>', '?', '~', '`'
        ],
        'ru' => [
            'ф', 'ы', 'в', 'а', 'о', 'л', 'д', 'ж',
            'й', 'ц', 'у', 'к', 'е', 'н', 'г', 'ш', 'щ', 'з', 'х', 'ъ',
            'я', 'ч', 'с', 'м', 'и', 'т', 'ь', 'б', 'ю', 'п', 'р', 'э',
            'ё',
            'Ф', 'Ы', 'В', 'А', 'О', 'Л', 'Д', 'Ж',
            'Й', 'Ц', 'У', 'К', 'Е', 'Н', 'Г', 'Ш', 'Щ', 'З', 'Х', 'Ъ',
            'Я', 'Ч', 'С', 'М', 'И', 'Т', 'Ь', 'Б', 'Ю', 'П', 'Р', 'Э',
            'Ё',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '"', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '/', ',', '.', '<', '>', '?', ':', ';'
        ],
    ];

    protected $pairedMap = [
        '(' => ')',
        '[' => ']',
        '{' => '}',
        '<' => '>',
        '"' => '"',
        "'" => "'",
        '`' => '`'
    ];

    protected $minLessonLength = 100;
    protected $maxLessonLength = 1000;
    protected $minWordsPerLine = 2;
    protected $maxWordsPerLine = 8;

    public function generateLessons(string $language, int $lessonCount, int $userId): void
    {
        $chars = $this->introductionOrder[$language] ?? $this->introductionOrder['en'];
        $totalChars = count($chars);
        $charsPerLesson = max(1, ceil($totalChars / $lessonCount));

        Lesson::where('language', $language)->where('user_id', $userId)->delete();

        for ($i = 0; $i < $lessonCount; $i++) {
            $start = $i * $charsPerLesson;
            $newChars = array_slice($chars, $start, $charsPerLesson);
            if (empty($newChars) && $i > 0) {
                $newChars = array_slice($chars, ($i - 1) * $charsPerLesson, $charsPerLesson);
            }
            if ($newChars) {
                Lesson::create([
                    'user_id' => $userId,
                    'number' => $i + 1,
                    'language' => $language,
                    'new_chars' => implode('', $newChars),
                ]);
            }
        }
    }

    public function generateLessonText(string $language, int $lessonNumber, int $userId, ?int $length = null): string
    {
        $availableChars = '';
        $newChars = '';

        $lessons = Lesson::where('language', $language)->where('user_id', $userId)->where('number', '<=', $lessonNumber)->get();
        foreach ($lessons as $lesson) {
            $availableChars .= $lesson->new_chars;
            if ($lesson->number == $lessonNumber) {
                $newChars = $lesson->new_chars;
            }
        }

        $availableCharsArray = mb_str_split($availableChars, 1, 'UTF-8');
        $newCharsArray = mb_str_split($newChars, 1, 'UTF-8');

        if (empty($availableCharsArray)) {
            return '';
        }

        $totalLessons = Lesson::where('language', $language)->where('user_id', $userId)->max('number') ?? 1;
        if ($length === null) {
            if ($totalLessons <= 1) {
                $length = $this->minLessonLength;
            } else {
                $length = $this->minLessonLength + ($this->maxLessonLength - $this->minLessonLength) * ($lessonNumber - 1) / ($totalLessons - 1);
            }
        }

        $text = '';
        $wordsAdded = 0;
        $lineWordCount = 0;
        $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
        $isFirstOfPair = true;
        $baseWord = null;

        while (mb_strlen($text) < $length) {
            if ($wordsAdded > 0) {
                if ($lineWordCount >= $currentLineWords) {
                    $separator = "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                } else {
                    $separator = " ";
                }
                if (mb_strlen($text) + mb_strlen($separator) > $length) {
                    break;
                }
                $text .= $separator;
            }

            if ($isFirstOfPair) {
                $baseWord = $this->generateEnhancedWord($availableCharsArray, $newCharsArray, $language);
                $currentWord = $baseWord;
                $isFirstOfPair = false;

                $remainingAfterFirst = $length - mb_strlen($text) - mb_strlen($currentWord);
                if ($wordsAdded > 0) {
                    $remainingAfterFirst -= mb_strlen($separator);
                }
                $remainingAfterSecond = $remainingAfterFirst - mb_strlen(" ") - mb_strlen($currentWord);

                if ($remainingAfterFirst < 0 || $remainingAfterSecond < 0) {
                    break;
                }

                if ($lineWordCount + 2 > $currentLineWords) {
                    $text .= "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                }
            } else {
                $currentWord = $baseWord;
                $isFirstOfPair = true;
            }

            $remaining = $length - mb_strlen($text);
            if (mb_strlen($currentWord) > $remaining) {
                $currentWord = mb_substr($currentWord, 0, $remaining);
            }

            $text .= $currentWord;

            if (mb_strlen($currentWord) >= 3) {
                $wordsAdded++;
                $lineWordCount++;
            }
        }

        $lines = explode("\n", $text);
        $lines = array_map('rtrim', $lines);
        $text = implode("\n", $lines);

        return mb_substr($text, 0, $length);
    }

    private function generateEnhancedWord(array $availableCharsArray, array $newCharsArray, string $language): string
    {
        $availableLetters = array_filter($availableCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $newLetters = array_filter($newCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $allVowels = $this->getVowels($language);
        $availableVowels = array_intersect($allVowels, $availableLetters);
        $newVowels = array_intersect($allVowels, $newLetters);

        $allConsonants = $this->getConsonants($language);
        $availableConsonants = array_intersect($allConsonants, $availableLetters);
        $newConsonants = array_intersect($allConsonants, $newLetters);

        $availableNumbers = array_filter($availableLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $newNumbers = array_filter($newLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $wordLength = random_int(3, 8);
        $letterPart = '';

        if (!empty($availableVowels) && !empty($availableConsonants)) {
            $startType = rand(0, 1) == 0 ? 'V' : 'C';
            $startSet = $startType == 'V' ? $availableVowels : $availableConsonants;
            $startSetNew = $startType == 'V' ? $newVowels : $newConsonants;
            $otherSet = $startType == 'V' ? $availableConsonants : $availableVowels;
            $otherSetNew = $startType == 'V' ? $newConsonants : $newVowels;
        } elseif (!empty($availableVowels)) {
            $startSet = $availableVowels;
            $startSetNew = $newVowels;
            $otherSet = [];
            $otherSetNew = [];
        } elseif (!empty($availableConsonants)) {
            $startSet = $availableConsonants;
            $startSetNew = $newConsonants;
            $otherSet = [];
            $otherSetNew = [];
        } else {
            return '';
        }

        for ($i = 0; $i < $wordLength; $i++) {
            $set = ($i % 2 == 0) ? $startSet : $otherSet;
            $setNew = ($i % 2 == 0) ? $startSetNew : $otherSetNew;

            if (empty($set)) {
                $set = $availableLetters;
                $setNew = $newLetters;
            }

            $useNumber = !empty($availableNumbers) && rand(0, 99) < 30;
            if ($useNumber) {
                if (!empty($newNumbers) && rand(0, 99) < 70) {
                    $letterPart .= $newNumbers[array_rand($newNumbers)];
                } else {
                    $letterPart .= $availableNumbers[array_rand($availableNumbers)];
                }
            } else {
                if (!empty($setNew) && rand(0, 99) < 70) {
                    $letterPart .= $setNew[array_rand($setNew)];
                } else {
                    $letterPart .= $set[array_rand($set)];
                }
            }
        }

        $availableSpecials = array_filter($availableCharsArray, function ($char) {
            return !preg_match('/[a-zA-Z0-9а-яА-ЯёЁ]/u', $char);
        });

        $pairedSymbols = array_merge(array_keys($this->pairedMap), array_values($this->pairedMap));
        $singleSpecials = array_diff($availableSpecials, $pairedSymbols);

        $possiblePairedOpenings = ['(', '[', '{', '<', '"', "'", '`'];
        $availablePairedOpenings = array_intersect($possiblePairedOpenings, $availableSpecials);
        $availablePaired = [];

        foreach ($availablePairedOpenings as $opening) {
            if (in_array($this->pairedMap[$opening], $availableSpecials)) {
                $availablePaired[] = $opening;
            }
        }

        $totalOptions = ['none'];
        if (!empty($singleSpecials)) {
            $totalOptions[] = 'single';
        }
        if (!empty($availablePaired)) {
            $totalOptions[] = 'paired';
        }

        $type = $totalOptions[array_rand($totalOptions)];

        if ($type == 'none') {
            return $letterPart;
        } elseif ($type == 'single') {
            $special = $singleSpecials[array_rand($singleSpecials)];
            if ($this->isPunctuation($special)) {
                return $letterPart . $special;
            }
            $position = rand(0, 1) == 0 ? 'start' : 'end';
            return $position == 'start' ? $special . $letterPart : $letterPart . $special;
        } else {
            $opening = $availablePaired[array_rand($availablePaired)];
            $closing = $this->pairedMap[$opening];
            return $opening . $letterPart . $closing;
        }
    }

    private function isPunctuation(string $char): bool
    {
        return in_array($char, [',', '.', ';', ':', '!', '?']);
    }

    private function getVowels(string $language): array
    {
        if ($language == 'ru') {
            return ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я', 'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я'];
        } elseif ($language == 'en') {
            return ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];
        }
        return [];
    }

    private function getConsonants(string $language): array
    {
        if ($language == 'ru') {
            return array_diff($this->getRussianLetters(), $this->getVowels('ru'));
        } elseif ($language == 'en') {
            return array_diff($this->getEnglishLetters(), $this->getVowels('en'));
        }
        return [];
    }

    private function getRussianLetters(): array
    {
        return array_merge(
            ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я'],
            ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я']
        );
    }

    private function getEnglishLetters(): array
    {
        return array_merge(
            range('a', 'z'),
            range('A', 'Z')
        );
    }
}
Описание изменений
В методе generateLessons добавлена проверка: если newChars пустой для текущего урока (что может произойти, если символы закончились), используются символы из предыдущего урока (array_slice($chars, ($i - 1) * $charsPerLesson, $charsPerLesson)). Это гарантирует, что будет создано ровно $lessonCount уроков, даже если символов меньше, чем нужно для равномерного распределения. Изменение минимально и не затрагивает другие части кода.

Другие файлы (LessonController.php, routes/api.php, resources/js/router/index.ts, LessonSetup.vue, Lesson.vue) остались без изменений, так как проблема решается исключительно в LessonService.php.







Это не решило проблему. Я выбрал создать 16 уроков, а создалось 15, и в базе данных 15 уроков.


Проблема сохраняется из-за того, что в методе generateLessons в LessonService.php логика распределения символов по урокам не гарантирует создание ровно указанного количества уроков. Основная причина — использование ceil(count($chars) / $lessonCount) и последующее деление символов, которое может привести к пропуску последнего урока, если символы не распределяются равномерно. Чтобы исправить это, нужно обеспечить создание ровно $lessonCount уроков, распределяя символы циклически, если их недостаточно, и убедиться, что каждый урок содержит хотя бы один символ.

Ниже приведен обновленный код файла app/Services/LessonService.php с минимальными изменениями, решающими проблему. Остальные файлы остаются без изменений, так как проблема локализована в LessonService.php.

x

Копировать
<?php

namespace App\Services;

use App\Models\Lesson;

class LessonService
{
    protected $introductionOrder = [
        'en' => [
            'a', 's', 'd', 'f', 'j', 'k', 'l', ';',
            'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
            'h', 'g', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',
            'A', 'S', 'D', 'F', 'J', 'K', 'L', ';',
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
            'H', 'G', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '\\', ':', '"', '\'', '<', '>', '?', '~', '`'
        ],
        'ru' => [
            'ф', 'ы', 'в', 'а', 'о', 'л', 'д', 'ж',
            'й', 'ц', 'у', 'к', 'е', 'н', 'г', 'ш', 'щ', 'з', 'х', 'ъ',
            'я', 'ч', 'с', 'м', 'и', 'т', 'ь', 'б', 'ю', 'п', 'р', 'э',
            'ё',
            'Ф', 'Ы', 'В', 'А', 'О', 'Л', 'Д', 'Ж',
            'Й', 'Ц', 'У', 'К', 'Е', 'Н', 'Г', 'Ш', 'Щ', 'З', 'Х', 'Ъ',
            'Я', 'Ч', 'С', 'М', 'И', 'Т', 'Ь', 'Б', 'Ю', 'П', 'Р', 'Э',
            'Ё',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '"', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '/', ',', '.', '<', '>', '?', ':', ';'
        ],
    ];

    protected $pairedMap = [
        '(' => ')',
        '[' => ']',
        '{' => '}',
        '<' => '>',
        '"' => '"',
        "'" => "'",
        '`' => '`'
    ];

    protected $minLessonLength = 100;
    protected $maxLessonLength = 1000;
    protected $minWordsPerLine = 2;
    protected $maxWordsPerLine = 8;

    public function generateLessons(string $language, int $lessonCount, int $userId): void
    {
        $chars = $this->introductionOrder[$language] ?? $this->introductionOrder['en'];
        $totalChars = count($chars);

        Lesson::where('language', $language)->where('user_id', $userId)->delete();

        for ($i = 0; $i < $lessonCount; $i++) {
            $charsPerLesson = max(1, ceil($totalChars / max(1, $lessonCount - $i)));
            $newChars = [];
            for ($j = 0; $j < $charsPerLesson && !empty($chars); $j++) {
                $newChars[] = array_shift($chars);
            }
            if (empty($newChars) && !empty($this->introductionOrder[$language])) {
                $newChars = array_slice($this->introductionOrder[$language], 0, max(1, ceil($totalChars / $lessonCount)));
            }
            Lesson::create([
                'user_id' => $userId,
                'number' => $i + 1,
                'language' => $language,
                'new_chars' => implode('', $newChars),
            ]);
        }
    }

    public function generateLessonText(string $language, int $lessonNumber, int $userId, ?int $length = null): string
    {
        $availableChars = '';
        $newChars = '';

        $lessons = Lesson::where('language', $language)->where('user_id', $userId)->where('number', '<=', $lessonNumber)->get();
        foreach ($lessons as $lesson) {
            $availableChars .= $lesson->new_chars;
            if ($lesson->number == $lessonNumber) {
                $newChars = $lesson->new_chars;
            }
        }

        $availableCharsArray = mb_str_split($availableChars, 1, 'UTF-8');
        $newCharsArray = mb_str_split($newChars, 1, 'UTF-8');

        if (empty($availableCharsArray)) {
            return '';
        }

        $totalLessons = Lesson::where('language', $language)->where('user_id', $userId)->max('number') ?? 1;
        if ($length === null) {
            if ($totalLessons <= 1) {
                $length = $this->minLessonLength;
            } else {
                $length = $this->minLessonLength + ($this->maxLessonLength - $this->minLessonLength) * ($lessonNumber - 1) / ($totalLessons - 1);
            }
        }

        $text = '';
        $wordsAdded = 0;
        $lineWordCount = 0;
        $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
        $isFirstOfPair = true;
        $baseWord = null;

        while (mb_strlen($text) < $length) {
            if ($wordsAdded > 0) {
                if ($lineWordCount >= $currentLineWords) {
                    $separator = "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                } else {
                    $separator = " ";
                }
                if (mb_strlen($text) + mb_strlen($separator) > $length) {
                    break;
                }
                $text .= $separator;
            }

            if ($isFirstOfPair) {
                $baseWord = $this->generateEnhancedWord($availableCharsArray, $newCharsArray, $language);
                $currentWord = $baseWord;
                $isFirstOfPair = false;

                $remainingAfterFirst = $length - mb_strlen($text) - mb_strlen($currentWord);
                if ($wordsAdded > 0) {
                    $remainingAfterFirst -= mb_strlen($separator);
                }
                $remainingAfterSecond = $remainingAfterFirst - mb_strlen(" ") - mb_strlen($currentWord);

                if ($remainingAfterFirst < 0 || $remainingAfterSecond < 0) {
                    break;
                }

                if ($lineWordCount + 2 > $currentLineWords) {
                    $text .= "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                }
            } else {
                $currentWord = $baseWord;
                $isFirstOfPair = true;
            }

            $remaining = $length - mb_strlen($text);
            if (mb_strlen($currentWord) > $remaining) {
                $currentWord = mb_substr($currentWord, 0, $remaining);
            }

            $text .= $currentWord;

            if (mb_strlen($currentWord) >= 3) {
                $wordsAdded++;
                $lineWordCount++;
            }
        }

        $lines = explode("\n", $text);
        $lines = array_map('rtrim', $lines);
        $text = implode("\n", $lines);

        return mb_substr($text, 0, $length);
    }

    private function generateEnhancedWord(array $availableCharsArray, array $newCharsArray, string $language): string
    {
        $availableLetters = array_filter($availableCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $newLetters = array_filter($newCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $allVowels = $this->getVowels($language);
        $availableVowels = array_intersect($allVowels, $availableLetters);
        $newVowels = array_intersect($allVowels, $newLetters);

        $allConsonants = $this->getConsonants($language);
        $availableConsonants = array_intersect($allConsonants, $availableLetters);
        $newConsonants = array_intersect($allConsonants, $newLetters);

        $availableNumbers = array_filter($availableLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $newNumbers = array_filter($newLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $wordLength = random_int(3, 8);
        $letterPart = '';

        if (!empty($availableVowels) && !empty($availableConsonants)) {
            $startType = rand(0, 1) == 0 ? 'V' : 'C';
            $startSet = $startType == 'V' ? $availableVowels : $availableConsonants;
            $startSetNew = $startType == 'V' ? $newVowels : $newConsonants;
            $otherSet = $startType == 'V' ? $availableConsonants : $availableVowels;
            $otherSetNew = $startType == 'V' ? $newConsonants : $newVowels;
        } elseif (!empty($availableVowels)) {
            $startSet = $availableVowels;
            $startSetNew = $newVowels;
            $otherSet = [];
            $otherSetNew = [];
        } elseif (!empty($availableConsonants)) {
            $startSet = $availableConsonants;
            $startSetNew = $newConsonants;
            $otherSet = [];
            $otherSetNew = [];
        } else {
            return '';
        }

        for ($i = 0; $i < $wordLength; $i++) {
            $set = ($i % 2 == 0) ? $startSet : $otherSet;
            $setNew = ($i % 2 == 0) ? $startSetNew : $otherSetNew;

            if (empty($set)) {
                $set = $availableLetters;
                $setNew = $newLetters;
            }

            $useNumber = !empty($availableNumbers) && rand(0, 99) < 30;
            if ($useNumber) {
                if (!empty($newNumbers) && rand(0, 99) < 70) {
                    $letterPart .= $newNumbers[array_rand($newNumbers)];
                } else {
                    $letterPart .= $availableNumbers[array_rand($availableNumbers)];
                }
            } else {
                if (!empty($setNew) && rand(0, 99) < 70) {
                    $letterPart .= $setNew[array_rand($setNew)];
                } else {
                    $letterPart .= $set[array_rand($set)];
                }
            }
        }

        $availableSpecials = array_filter($availableCharsArray, function ($char) {
            return !preg_match('/[a-zA-Z0-9а-яА-ЯёЁ]/u', $char);
        });

        $pairedSymbols = array_merge(array_keys($this->pairedMap), array_values($this->pairedMap));
        $singleSpecials = array_diff($availableSpecials, $pairedSymbols);

        $possiblePairedOpenings = ['(', '[', '{', '<', '"', "'", '`'];
        $availablePairedOpenings = array_intersect($possiblePairedOpenings, $availableSpecials);
        $availablePaired = [];

        foreach ($availablePairedOpenings as $opening) {
            if (in_array($this->pairedMap[$opening], $availableSpecials)) {
                $availablePaired[] = $opening;
            }
        }

        $totalOptions = ['none'];
        if (!empty($singleSpecials)) {
            $totalOptions[] = 'single';
        }
        if (!empty($availablePaired)) {
            $totalOptions[] = 'paired';
        }

        $type = $totalOptions[array_rand($totalOptions)];

        if ($type == 'none') {
            return $letterPart;
        } elseif ($type == 'single') {
            $special = $singleSpecials[array_rand($singleSpecials)];
            if ($this->isPunctuation($special)) {
                return $letterPart . $special;
            }
            $position = rand(0, 1) == 0 ? 'start' : 'end';
            return $position == 'start' ? $special . $letterPart : $letterPart . $special;
        } else {
            $opening = $availablePaired[array_rand($availablePaired)];
            $closing = $this->pairedMap[$opening];
            return $opening . $letterPart . $closing;
        }
    }

    private function isPunctuation(string $char): bool
    {
        return in_array($char, [',', '.', ';', ':', '!', '?']);
    }

    private function getVowels(string $language): array
    {
        if ($language == 'ru') {
            return ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я', 'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я'];
        } elseif ($language == 'en') {
            return ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];
        }
        return [];
    }

    private function getConsonants(string $language): array
    {
        if ($language == 'ru') {
            return array_diff($this->getRussianLetters(), $this->getVowels('ru'));
        } elseif ($language == 'en') {
            return array_diff($this->getEnglishLetters(), $this->getVowels('en'));
        }
        return [];
    }

    private function getRussianLetters(): array
    {
        return array_merge(
            ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я'],
            ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я']
        );
    }

    private function getEnglishLetters(): array
    {
        return array_merge(
            range('a', 'z'),
            range('A', 'Z')
        );
    }
}
Показать в боковой панели
Описание изменений
В методе generateLessons изменена логика распределения символов:

Удалены старые уроки для пользователя и языка.
Для каждого из $lessonCount уроков:
Вычисляется количество символов на урок как ceil($totalChars / max(1, $lessonCount - $i)), где $i — текущий номер урока, чтобы динамически уменьшать знаменатель по мере распределения символов.
Из массива $chars извлекаются символы с помощью array_shift для текущего урока.
Если символы закончились ($chars пуст), используются символы из исходного $introductionOrder[$language] (первые ceil($totalChars / $lessonCount) символов), чтобы гарантировать, что каждый урок содержит хотя бы один символ.
Создается запись в базе данных для каждого урока с номером $i + 1 и соответствующими символами.
Эти изменения обеспечивают создание ровно $lessonCount уроков, даже если символов недостаточно, путем циклического использования доступных символов. Остальные части кода остались без изменений, чтобы минимизировать вмешательство.








Чем я могу помочь?


DeepSearch


Think

Grok 3
