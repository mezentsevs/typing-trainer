Предоставляю контекстную информацию для выполнения задачи:
resources/js/components/FinalTestSetup.vue
<template>
    <div class="w-1/2 mx-auto my-4 border border-opacity-50 rounded-lg p-4">
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold">Genre (optional)</label>
            <select v-model="genre" class="p-2 border rounded w-full text-sm">
                <option value="">None</option>
                <option value="fiction">Fiction</option>
                <option value="non-fiction">Non-fiction</option>
                <option value="poetry">Poetry</option>
            </select>
        </div>
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold">Upload Text (optional)</label>
            <input type="file" accept=".txt" @change="uploadFile" class="p-2 border rounded w-full text-sm" />
        </div>
        <button @click="$emit('start-test')" class="bg-blue-500 text-white p-2 rounded w-full text-sm">Start Test</button>
    </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';

const genre = ref('');
defineProps<{
    uploadFile: (event: Event) => void;
}>();
defineEmits<{
    (e: 'start-test'): void;
}>();
</script>
resources/js/components/FinalTest.vue
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Final Test</h2>
                <span v-if="isTestCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <FinalTestSetup v-if="!text" :upload-file="uploadFile" @start-test="fetchText" />
            <Statistics v-if="text" :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div v-if="text" class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto bg-gray-50 p-2">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char, 'current-word': isCurrentWord[index], 'space': char === ' ', 'line-break': char === '\n' }">
                        {{ char }}
                    </span>
                </div>
                <textarea
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4 resize-none"
                    ref="input"
                    :disabled="isTestCompleted"
                    autofocus
                    rows="4"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <div v-if="isTestCompleted" class="flex justify-center mt-2">
                    <router-link to="/" class="bg-blue-500 text-white p-2 rounded">Back to Home</router-link>
                </div>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import FinalTestSetup from './FinalTestSetup.vue';
import { scrollToCurrentChar } from '@/helpers/DomHelper';
import { getCurrentTypingUnit } from '@/helpers/StringHelper';

const route = useRoute();
const language = ref(route.params.language as string);
const genre = ref('');
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLTextAreaElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const isTestCompleted = ref(false);

const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const fetchText = async () => {
    const response = await axios.get('/test/text', { params: { language: language.value, genre: genre.value } });
    text.value = response.data.text;
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isTestCompleted.value = false;
};

const uploadFile = async (event: Event) => {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('language', language.value);
        await axios.post('/test/upload', formData);
        await fetchText();
    }
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isTestCompleted.value = true;
        await axios.post('/test/result', {
            language: language.value,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

onMounted(() => {
    if (input.value) {
        input.value.focus();
    }
});

const currentTypingUnit = computed(() => getCurrentTypingUnit(text.value, typed.value.length));

const isCurrentWord = computed(() => {
    const range = currentTypingUnit.value;
    if (!range) return Array(text.value.length).fill(false);
    const arr = Array(text.value.length).fill(false);
    for (let i = range.start; i <= range.end; i++) {
        arr[i] = true;
    }
    return arr;
});
</script>
Сейчас жанр genre: genre.value не передается в функцию fetchText по событию start-test. Нужно это исправить с минимальными изменениями в коде. Выведи полный обновленный код компонентов, которые были изменены в процессе выполнения задачи.




Для передачи genre.value в функцию fetchText по событию start-test, нужно обновить компонент FinalTestSetup.vue, чтобы он передавал значение genre через событие start-test, и компонент FinalTest.vue, чтобы он принимал и использовал это значение. Ниже приведен полный обновленный код измененных компонентов с минимальными изменениями.

resources/js/components/FinalTestSetup.vue
vue

Копировать
<template>
    <div class="w-1/2 mx-auto my-4 border border-opacity-50 rounded-lg p-4">
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold">Genre (optional)</label>
            <select v-model="genre" class="p-2 border rounded w-full text-sm">
                <option value="">None</option>
                <option value="fiction">Fiction</option>
                <option value="non-fiction">Non-fiction</option>
                <option value="poetry">Poetry</option>
            </select>
        </div>
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold">Upload Text (optional)</label>
            <input type="file" accept=".txt" @change="uploadFile" class="p-2 border rounded w-full text-sm" />
        </div>
        <button @click="$emit('start-test', genre)" class="bg-blue-500 text-white p-2 rounded w-full text-sm">Start Test</button>
    </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';

const genre = ref('');
defineProps<{
    uploadFile: (event: Event) => void;
}>();
defineEmits<{
    (e: 'start-test', genre: string): void;
}>();
</script>
Изменения:

В шаблоне изменен обработчик события @click для кнопки, чтобы передавать genre в событие start-test: @click="$emit('start-test', genre)".
В определении defineEmits добавлена сигнатура события start-test с параметром genre: string, чтобы TypeScript корректно обрабатывал типы.
resources/js/components/FinalTest.vue
vue

Копировать
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Final Test</h2>
                <span v-if="isTestCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <FinalTestSetup v-if="!text" :upload-file="uploadFile" @start-test="fetchText" />
            <Statistics v-if="text" :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div v-if="text" class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto bg-gray-50 p-2">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char, 'current-word': isCurrentWord[index], 'space': char === ' ', 'line-break': char === '\n' }">
                        {{ char }}
                    </span>
                </div>
                <textarea
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4 resize-none"
                    ref="input"
                    :disabled="isTestCompleted"
                    autofocus
                    rows="4"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <div v-if="isTestCompleted" class="flex justify-center mt-2">
                    <router-link to="/" class="bg-blue-500 text-white p-2 rounded">Back to Home</router-link>
                </div>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import FinalTestSetup from './FinalTestSetup.vue';
import { scrollToCurrentChar } from '@/helpers/DomHelper';
import { getCurrentTypingUnit } from '@/helpers/StringHelper';

const route = useRoute();
const language = ref(route.params.language as string);
const genre = ref('');
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLTextAreaElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const isTestCompleted = ref(false);

const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const fetchText = async (selectedGenre: string) => {
    genre.value = selectedGenre;
    const response = await axios.get('/test/text', { params: { language: language.value, genre: genre.value } });
    text.value = response.data.text;
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isTestCompleted.value = false;
};

const uploadFile = async (event: Event) => {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('language', language.value);
        await axios.post('/test/upload', formData);
        await fetchText(genre.value);
    }
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isTestCompleted.value = true;
        await axios.post('/test/result', {
            language: language.value,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

onMounted(() => {
    if (input.value) {
        input.value.focus();
    }
});

const currentTypingUnit = computed(() => getCurrentTypingUnit(text.value, typed.value.length));

const isCurrentWord = computed(() => {
    const range = currentTypingUnit.value;
    if (!range) return Array(text.value.length).fill(false);
    const arr = Array(text.value.length).fill(false);
    for (let i = range.start; i <= range.end; i++) {
        arr[i] = true;
    }
    return arr;
});
</script>
Изменения:

Функция fetchText теперь принимает параметр selectedGenre: string и присваивает его genre.value перед отправкой запроса.
В шаблоне событие @start-test="fetchText" остается без изменений, так как Vue автоматически передаст аргумент события в функцию.
В функции uploadFile вызов fetchText обновлен, чтобы передать текущее значение genre.value: await fetchText(genre.value).
Эти изменения обеспечивают передачу выбранного жанра в функцию fetchText при запуске теста, сохраняя минимальные изменения в коде. Теперь значение genre будет корректно отправляться в запрос /test/text.






Чем я могу помочь?


DeepSearch


Think

Grok 3
