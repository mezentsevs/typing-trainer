В web приложении для тренировки навыка слепой печати генерируются уроки. Предоставляю контекстные данные для выполнения задачи:
database/migrations/0001_01_01_000000_create_users_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};
database/migrations/2025_04_14_000001_create_lessons_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('lessons', function (Blueprint $table) {
            $table->id();
            $table->unsignedInteger('number');
            $table->string('language');
            $table->string('new_chars');
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('lessons');
    }
};
app/Models/User.php
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory, HasApiTokens, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }
}
app/Models/Lesson.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Lesson extends Model
{
    use HasFactory;

    protected $fillable = ['number', 'language', 'new_chars'];

    public function progresses()
    {
        return $this->hasMany(LessonProgress::class);
    }
}
app/Http/Controllers/LessonController.php
<?php

namespace App\Http\Controllers;

use App\Models\Lesson;
use App\Models\LessonProgress;
use App\Services\LessonService;
use Illuminate\Http\Request;

class LessonController extends Controller
{
    protected $lessonService;

    public function __construct(LessonService $lessonService)
    {
        $this->lessonService = $lessonService;
    }

    public function generate(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'lesson_count' => 'required|integer|min:1',
        ]);

        $this->lessonService->generateLessons($request->language, $request->lesson_count);

        return response()->json(['message' => 'Lessons generated']);
    }

    public function index(string $language)
    {
        $lessons = Lesson::where('language', $language)->get();
        return response()->json($lessons);
    }

    public function getText(string $language, int $lessonNumber)
    {
        $text = $this->lessonService->generateLessonText($language, $lessonNumber);
        return response()->json(['text' => $text]);
    }

    public function saveProgress(Request $request)
    {
        $request->validate([
            'lesson_id' => 'required|exists:lessons,id',
            'time_seconds' => 'required|integer',
            'speed_wpm' => 'required|integer',
            'errors' => 'required|integer',
        ]);

        $progress = LessonProgress::create([
            'user_id' => auth()->id(),
            'lesson_id' => $request->lesson_id,
            'time_seconds' => $request->time_seconds,
            'speed_wpm' => $request->speed_wpm,
            'errors' => $request->errors,
        ]);

        return response()->json($progress);
    }
}
app/Services/LessonService.php
<?php

namespace App\Services;

use App\Models\Lesson;

class LessonService
{
    protected $charSets = [
        'en' => 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?',
        'ru' => 'абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?',
    ];

    public function generateLessons(string $language, int $lessonCount): void
    {
        $chars = mb_str_split($this->charSets[$language] ?? $this->charSets['en'], 1, 'UTF-8');
        $charsPerLesson = ceil(count($chars) / $lessonCount);

        Lesson::where('language', $language)->delete();

        for ($i = 0; $i < $lessonCount; $i++) {
            $start = $i * $charsPerLesson;
            $newChars = array_slice($chars, $start, $charsPerLesson);
            if ($newChars) {
                Lesson::create([
                    'number' => $i + 1,
                    'language' => $language,
                    'new_chars' => implode('', $newChars),
                ]);
            }
        }
    }

    public function generateLessonText(string $language, int $lessonNumber, int $length = 100): string
    {
        $availableChars = '';
        foreach (Lesson::where('language', $language)->where('number', '<=', $lessonNumber)->get() as $l) {
            $availableChars .= $l->new_chars;
        }

        $availableChars = mb_str_split($availableChars, 1, 'UTF-8');
        $text = '';
        for ($i = 0; $i < $length; $i++) {
            $text .= $availableChars[random_int(0, count($availableChars) - 1)];
        }

        return $text;
    }
}
Сейчас генерация уроков не привязана к конкретному пользователю. Нужно сделать, чтобы уроки генерировались отдельно для каждого пользователя, и были привязаны к с своему конкретному пользователю, чтобы конкретный пользователь мог использовать только свои уроки, и мог перегенерировать только свои уроки. Минимальные изменения. Выведи обновленный код всех необходимых для выполнения задачи файлов.




To make lessons user-specific, we need to:

Add a user_id foreign key to the lessons table
Update the Lesson model to include the user relationship
Modify LessonService to generate lessons for a specific user
Update LessonController to handle user-specific lesson generation and retrieval
Here are the updated files with minimal changes:

php

Копировать
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('lessons', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->unsignedInteger('number');
            $table->string('language');
            $table->string('new_chars');
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('lessons');
    }
};
Show in sidebar
php

Копировать
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Lesson extends Model
{
    use HasFactory;

    protected $fillable = ['user_id', 'number', 'language', 'new_chars'];

    public function progresses()
    {
        return $this->hasMany(LessonProgress::class);
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}
Show in sidebar
php

Копировать
<?php

namespace App\Services;

use App\Models\Lesson;

class LessonService
{
    protected $charSets = [
        'en' => 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?',
        'ru' => 'абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?',
    ];

    public function generateLessons(string $language, int $lessonCount, int $userId): void
    {
        $chars = mb_str_split($this->charSets[$language] ?? $this->charSets['en'], 1, 'UTF-8');
        $charsPerLesson = ceil(count($chars) / $lessonCount);

        Lesson::where('language', $language)->where('user_id', $userId)->delete();

        for ($i = 0; $i < $lessonCount; $i++) {
            $start = $i * $charsPerLesson;
            $newChars = array_slice($chars, $start, $charsPerLesson);
            if ($newChars) {
                Lesson::create([
                    'user_id' => $userId,
                    'number' => $i + 1,
                    'language' => $language,
                    'new_chars' => implode('', $newChars),
                ]);
            }
        }
    }

    public function generateLessonText(string $language, int $lessonNumber, int $userId, int $length = 100): string
    {
        $availableChars = '';
        foreach (Lesson::where('language', $language)->where('user_id', $userId)->where('number', '<=', $lessonNumber)->get() as $l) {
            $availableChars .= $l->new_chars;
        }

        $availableChars = mb_str_split($availableChars, 1, 'UTF-8');
        $text = '';
        for ($i = 0; $i < $length; $i++) {
            $text .= $availableChars[random_int(0, count($availableChars) - 1)];
        }

        return $text;
    }
}
Show in sidebar
php

Копировать
<?php

namespace App\Http\Controllers;

use App\Models\Lesson;
use App\Models\LessonProgress;
use App\Services\LessonService;
use Illuminate\Http\Request;

class LessonController extends Controller
{
    protected $lessonService;

    public function __construct(LessonService $lessonService)
    {
        $this->lessonService = $lessonService;
    }

    public function generate(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'lesson_count' => 'required|integer|min:1',
        ]);

        $this->lessonService->generateLessons($request->language, $request->lesson_count, auth()->id());

        return response()->json(['message' => 'Lessons generated']);
    }

    public function index(string $language)
    {
        $lessons = Lesson::where('language', $language)->where('user_id', auth()->id())->get();
        return response()->json($lessons);
    }

    public function getText(string $language, int $lessonNumber)
    {
        $text = $this->lessonService->generateLessonText($language, $lessonNumber, auth()->id());
        return response()->json(['text' => $text]);
    }

    public function saveProgress(Request $request)
    {
        $request->validate([
            'lesson_id' => 'required|exists:lessons,id',
            'time_seconds' => 'required|integer',
            'speed_wpm' => 'required|integer',
            'errors' => 'required|integer',
        ]);

        $progress = LessonProgress::create([
            'user_id' => auth()->id(),
            'lesson_id' => $request->lesson_id,
            'time_seconds' => $request->time_seconds,
            'speed_wpm' => $request->speed_wpm,
            'errors' => $request->errors,
        ]);

        return response()->json($progress);
    }
}
Show in sidebar
These changes:

Add user_id to lessons table with foreign key constraint
Update Lesson model to include user relationship and add user_id to fillable
Modify LessonService to accept userId parameter and filter by user
Update LessonController to pass authenticated user's ID and filter lessons by user
Maintain all existing functionality while ensuring lessons are user-specific
The database migration will need to be applied, and existing lessons (if any) may need to be handled during migration since they won't have a user_id initially.






Чем я могу помочь?


DeepSearch


Think

Grok 3

