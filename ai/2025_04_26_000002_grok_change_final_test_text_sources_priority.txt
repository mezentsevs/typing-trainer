В веб приложении для тренировки навыка слепой печати есть уроки и финальный тест. Предоставляю контекстную информацию для задачи:
routes/api.php
<?php

use App\Http\Controllers\AuthController;
use App\Http\Controllers\LessonController;
use App\Http\Controllers\TestController;
use Illuminate\Support\Facades\Route;

Route::post('/register', [AuthController::class, 'register']);
Route::post('/login', [AuthController::class, 'login']);

Route::middleware('auth:sanctum')->group(function () {
    Route::post('/logout', [AuthController::class, 'logout']);

    Route::prefix('lessons')->group(function () {
        Route::post('/generate', [LessonController::class, 'generate']);
        Route::get('/{language}', [LessonController::class, 'index']);
        Route::get('/{language}/{lessonNumber}/text', [LessonController::class, 'getText']);
        Route::post('/progress', [LessonController::class, 'saveProgress']);
    });

    Route::prefix('test')->group(function () {
        Route::get('/text', [TestController::class, 'getTestText']);
        Route::post('/upload', [TestController::class, 'uploadText']);
        Route::post('/result', [TestController::class, 'saveResult']);
    });
});
resources/js/router/index.ts
import { createRouter, createWebHistory } from 'vue-router';
import Home from '@/components/Home.vue';
import Login from '@/components/Login.vue';
import Register from '@/components/Register.vue';
import LessonSetup from '@/components/LessonSetup.vue';
import Lesson from '@/components/Lesson.vue';
import FinalTest from '@/components/FinalTest.vue';

const routes = [
    { path: '/', component: Home, meta: { requiresAuth: true } },
    { path: '/login', component: Login },
    { path: '/register', component: Register },
    { path: '/setup', component: LessonSetup, meta: { requiresAuth: true } },
    { path: '/lesson/:language/:number', component: Lesson, meta: { requiresAuth: true } },
    { path: '/test/:language', component: FinalTest, meta: { requiresAuth: true } },
];

const router = createRouter({
    history: createWebHistory(),
    routes,
});

router.beforeEach((to, from, next) => {
    const token = localStorage.getItem('token');
    if (to.meta.requiresAuth && !token) {
        next('/login');
    } else {
        next();
    }
});

export default router;
app/Http/Controllers/LessonController.php
<?php

namespace App\Http\Controllers;

use App\Models\Lesson;
use App\Models\LessonProgress;
use App\Services\LessonService;
use Illuminate\Http\Request;

class LessonController extends Controller
{
    protected $lessonService;

    public function __construct(LessonService $lessonService)
    {
        $this->lessonService = $lessonService;
    }

    public function generate(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'lesson_count' => 'required|integer|min:1',
        ]);

        $this->lessonService->generateLessons($request->language, $request->lesson_count, auth()->id());

        return response()->json(['message' => 'Lessons generated']);
    }

    public function index(string $language)
    {
        $lessons = Lesson::where('language', $language)->where('user_id', auth()->id())->get();
        return response()->json($lessons);
    }

    public function getText(string $language, int $lessonNumber)
    {
        $text = $this->lessonService->generateLessonText($language, $lessonNumber, auth()->id());
        return response()->json(['text' => $text]);
    }

    public function saveProgress(Request $request)
    {
        $request->validate([
            'lesson_id' => 'required|exists:lessons,id',
            'language' => 'required|string',
            'time_seconds' => 'required|integer',
            'speed_wpm' => 'required|integer',
            'errors' => 'required|integer',
        ]);

        $progress = LessonProgress::create([
            'user_id' => auth()->id(),
            'lesson_id' => $request->lesson_id,
            'language' => $request->language,
            'time_seconds' => $request->time_seconds,
            'speed_wpm' => $request->speed_wpm,
            'errors' => $request->errors,
        ]);

        return response()->json($progress);
    }
}
app/Services/LessonService.php
<?php

namespace App\Services;

use App\Models\Lesson;

class LessonService
{
    protected $introductionOrder = [
        'en' => [
            'a', 's', 'd', 'f', 'j', 'k', 'l', ';',
            'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
            'h', 'g', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',
            'A', 'S', 'D', 'F', 'J', 'K', 'L', ';',
            'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
            'H', 'G', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '\\', ':', '"', '\'', '<', '>', '?', '~', '`'
        ],
        'ru' => [
            'ф', 'ы', 'в', 'а', 'о', 'л', 'д', 'ж',
            'й', 'ц', 'у', 'к', 'е', 'н', 'г', 'ш', 'щ', 'з', 'х', 'ъ',
            'я', 'ч', 'с', 'м', 'и', 'т', 'ь', 'б', 'ю', 'п', 'р', 'э',
            'ё',
            'Ф', 'Ы', 'В', 'А', 'О', 'Л', 'Д', 'Ж',
            'Й', 'Ц', 'У', 'К', 'Е', 'Н', 'Г', 'Ш', 'Щ', 'З', 'Х', 'Ъ',
            'Я', 'Ч', 'С', 'М', 'И', 'Т', 'Ь', 'Б', 'Ю', 'П', 'Р', 'Э',
            'Ё',
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
            '!', '"', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '[', ']', '{', '}', '|', '/', ',', '.', '<', '>', '?', ':', ';'
        ],
    ];

    protected $pairedMap = [
        '(' => ')',
        '[' => ']',
        '{' => '}',
        '<' => '>',
        '"' => '"',
        "'" => "'",
        '`' => '`'
    ];

    protected $minLessonLength = 100;
    protected $maxLessonLength = 1000;
    protected $minWordsPerLine = 2;
    protected $maxWordsPerLine = 8;

    public function generateLessons(string $language, int $lessonCount, int $userId): void
    {
        $chars = $this->introductionOrder[$language] ?? $this->introductionOrder['en'];
        $charsPerLesson = ceil(count($chars) / $lessonCount);

        Lesson::where('language', $language)->where('user_id', $userId)->delete();

        for ($i = 0; $i < $lessonCount; $i++) {
            $start = $i * $charsPerLesson;
            $newChars = array_slice($chars, $start, $charsPerLesson);
            if ($newChars) {
                Lesson::create([
                    'user_id' => $userId,
                    'number' => $i + 1,
                    'language' => $language,
                    'new_chars' => implode('', $newChars),
                ]);
            }
        }
    }

    public function generateLessonText(string $language, int $lessonNumber, int $userId, ?int $length = null): string
    {
        $availableChars = '';
        $newChars = '';

        $lessons = Lesson::where('language', $language)->where('user_id', $userId)->where('number', '<=', $lessonNumber)->get();
        foreach ($lessons as $lesson) {
            $availableChars .= $lesson->new_chars;
            if ($lesson->number == $lessonNumber) {
                $newChars = $lesson->new_chars;
            }
        }

        $availableCharsArray = mb_str_split($availableChars, 1, 'UTF-8');
        $newCharsArray = mb_str_split($newChars, 1, 'UTF-8');

        if (empty($availableCharsArray)) {
            return '';
        }

        $totalLessons = Lesson::where('language', $language)->where('user_id', $userId)->max('number') ?? 1;
        if ($length === null) {
            if ($totalLessons <= 1) {
                $length = $this->minLessonLength;
            } else {
                $length = $this->minLessonLength + ($this->maxLessonLength - $this->minLessonLength) * ($lessonNumber - 1) / ($totalLessons - 1);
            }
        }

        $text = '';
        $wordsAdded = 0;
        $lineWordCount = 0;
        $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
        $isFirstOfPair = true;
        $baseWord = null;

        while (mb_strlen($text) < $length) {
            if ($wordsAdded > 0) {
                if ($lineWordCount >= $currentLineWords) {
                    $separator = "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                } else {
                    $separator = " ";
                }
                if (mb_strlen($text) + mb_strlen($separator) > $length) {
                    break;
                }
                $text .= $separator;
            }

            if ($isFirstOfPair) {
                $baseWord = $this->generateEnhancedWord($availableCharsArray, $newCharsArray, $language);
                $currentWord = $baseWord;
                $isFirstOfPair = false;

                $remainingAfterFirst = $length - mb_strlen($text) - mb_strlen($currentWord);
                if ($wordsAdded > 0) {
                    $remainingAfterFirst -= mb_strlen($separator);
                }
                $remainingAfterSecond = $remainingAfterFirst - mb_strlen(" ") - mb_strlen($currentWord);

                if ($remainingAfterFirst < 0 || $remainingAfterSecond < 0) {
                    break;
                }

                if ($lineWordCount + 2 > $currentLineWords) {
                    $text .= "\n";
                    $lineWordCount = 0;
                    $currentLineWords = random_int($this->minWordsPerLine, $this->maxWordsPerLine);
                }
            } else {
                $currentWord = $baseWord;
                $isFirstOfPair = true;
            }

            $remaining = $length - mb_strlen($text);
            if (mb_strlen($currentWord) > $remaining) {
                $currentWord = mb_substr($currentWord, 0, $remaining);
            }

            $text .= $currentWord;

            if (mb_strlen($currentWord) >= 3) {
                $wordsAdded++;
                $lineWordCount++;
            }
        }

        $lines = explode("\n", $text);
        $lines = array_map('rtrim', $lines);
        $text = implode("\n", $lines);

        return mb_substr($text, 0, $length);
    }

    private function generateEnhancedWord(array $availableCharsArray, array $newCharsArray, string $language): string
    {
        $availableLetters = array_filter($availableCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $newLetters = array_filter($newCharsArray, function ($char) {
            return preg_match('/[a-zA-Zа-яА-ЯёЁ0-9]/u', $char);
        });

        $allVowels = $this->getVowels($language);
        $availableVowels = array_intersect($allVowels, $availableLetters);
        $newVowels = array_intersect($allVowels, $newLetters);

        $allConsonants = $this->getConsonants($language);
        $availableConsonants = array_intersect($allConsonants, $availableLetters);
        $newConsonants = array_intersect($allConsonants, $newLetters);

        $availableNumbers = array_filter($availableLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $newNumbers = array_filter($newLetters, function ($char) {
            return preg_match('/[0-9]/u', $char);
        });

        $wordLength = random_int(3, 8);
        $letterPart = '';

        if (!empty($availableVowels) && !empty($availableConsonants)) {
            $startType = rand(0, 1) == 0 ? 'V' : 'C';
            $startSet = $startType == 'V' ? $availableVowels : $availableConsonants;
            $startSetNew = $startType == 'V' ? $newVowels : $newConsonants;
            $otherSet = $startType == 'V' ? $availableConsonants : $availableVowels;
            $otherSetNew = $startType == 'V' ? $newConsonants : $newVowels;
        } elseif (!empty($availableVowels)) {
            $startSet = $availableVowels;
            $startSetNew = $newVowels;
            $otherSet = [];
            $otherSetNew = [];
        } elseif (!empty($availableConsonants)) {
            $startSet = $availableConsonants;
            $startSetNew = $newConsonants;
            $otherSet = [];
            $otherSetNew = [];
        } else {
            return '';
        }

        for ($i = 0; $i < $wordLength; $i++) {
            $set = ($i % 2 == 0) ? $startSet : $otherSet;
            $setNew = ($i % 2 == 0) ? $startSetNew : $otherSetNew;

            if (empty($set)) {
                $set = $availableLetters;
                $setNew = $newLetters;
            }

            $useNumber = !empty($availableNumbers) && rand(0, 99) < 30;
            if ($useNumber) {
                if (!empty($newNumbers) && rand(0, 99) < 70) {
                    $letterPart .= $newNumbers[array_rand($newNumbers)];
                } else {
                    $letterPart .= $availableNumbers[array_rand($availableNumbers)];
                }
            } else {
                if (!empty($setNew) && rand(0, 99) < 70) {
                    $letterPart .= $setNew[array_rand($setNew)];
                } else {
                    $letterPart .= $set[array_rand($set)];
                }
            }
        }

        $availableSpecials = array_filter($availableCharsArray, function ($char) {
            return !preg_match('/[a-zA-Z0-9а-яА-ЯёЁ]/u', $char);
        });

        $pairedSymbols = array_merge(array_keys($this->pairedMap), array_values($this->pairedMap));
        $singleSpecials = array_diff($availableSpecials, $pairedSymbols);

        $possiblePairedOpenings = ['(', '[', '{', '<', '"', "'", '`'];
        $availablePairedOpenings = array_intersect($possiblePairedOpenings, $availableSpecials);
        $availablePaired = [];

        foreach ($availablePairedOpenings as $opening) {
            if (in_array($this->pairedMap[$opening], $availableSpecials)) {
                $availablePaired[] = $opening;
            }
        }

        $totalOptions = ['none'];
        if (!empty($singleSpecials)) {
            $totalOptions[] = 'single';
        }
        if (!empty($availablePaired)) {
            $totalOptions[] = 'paired';
        }

        $type = $totalOptions[array_rand($totalOptions)];

        if ($type == 'none') {
            return $letterPart;
        } elseif ($type == 'single') {
            $special = $singleSpecials[array_rand($singleSpecials)];
            if ($this->isPunctuation($special)) {
                return $letterPart . $special;
            }
            $position = rand(0, 1) == 0 ? 'start' : 'end';
            return $position == 'start' ? $special . $letterPart : $letterPart . $special;
        } else {
            $opening = $availablePaired[array_rand($availablePaired)];
            $closing = $this->pairedMap[$opening];
            return $opening . $letterPart . $closing;
        }
    }

    private function isPunctuation(string $char): bool
    {
        return in_array($char, [',', '.', ';', ':', '!', '?']);
    }

    private function getVowels(string $language): array
    {
        if ($language == 'ru') {
            return ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я', 'А', 'Е', 'Ё', 'И', 'О', 'У', 'Ы', 'Э', 'Ю', 'Я'];
        } elseif ($language == 'en') {
            return ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];
        }
        return [];
    }

    private function getConsonants(string $language): array
    {
        if ($language == 'ru') {
            return array_diff($this->getRussianLetters(), $this->getVowels('ru'));
        } elseif ($language == 'en') {
            return array_diff($this->getEnglishLetters(), $this->getVowels('en'));
        }
        return [];
    }

    private function getRussianLetters(): array
    {
        return array_merge(
            ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я'],
            ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я']
        );
    }

    private function getEnglishLetters(): array
    {
        return array_merge(
            range('a', 'z'),
            range('A', 'Z')
        );
    }
}
app/Http/Controllers/TestController.php
<?php

namespace App\Http\Controllers;

use App\Models\TestResult;
use App\Services\TestService;
use Illuminate\Http\Request;

class TestController extends Controller
{
    protected $testService;

    public function __construct(TestService $testService)
    {
        $this->testService = $testService;
    }

    public function getTestText(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'genre' => 'nullable|string',
        ]);

        $text = $this->testService->getTestText($request->language, $request->genre, auth()->id());
        return response()->json(['text' => $text]);
    }

    public function uploadText(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'file' => 'required|file|mimes:txt',
        ]);

        $path = $request->file('file')->storeAs('uploads', "test_" . auth()->id() . "_{$request->language}.txt", 'public');
        return response()->json(['message' => 'File uploaded', 'path' => $path]);
    }

    public function saveResult(Request $request)
    {
        $request->validate([
            'language' => 'required|string',
            'time_seconds' => 'required|integer',
            'speed_wpm' => 'required|integer',
            'errors' => 'required|integer',
        ]);

        $result = TestResult::create([
            'user_id' => auth()->id(),
            'language' => $request->language,
            'time_seconds' => $request->time_seconds,
            'speed_wpm' => $request->speed_wpm,
            'errors' => $request->errors,
        ]);

        return response()->json($result);
    }
}
app/Services/TestService.php
<?php

namespace App\Services;

use App\Models\TestText;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;

class TestService
{
    public function getTestText(string $language, ?string $genre = null, int $userId): string
    {
        if (config('services.grok.key') && $genre) {
            try {
                $response = Http::withHeaders([
                    'Authorization' => 'Bearer ' . config('services.grok.key'),
                ])->post('https://api.x.ai/v1/generate', [
                    'prompt' => "Generate a 500-word text in $language for typing practice in the $genre genre.",
                ]);

                if ($response->successful()) {
                    return $response->json()['text'];
                }
            } catch (\Exception $e) {
                // Fallback to database text
            }
        }

        $filePath = "uploads/test_{$userId}_{$language}.txt";
        $userFile = Storage::disk('public')->exists($filePath)
            ? Storage::disk('public')->get($filePath)
            : null;

        if ($userFile) {
            return $userFile;
        }

        $query = TestText::where('language', $language);
        if ($genre) {
            $query->where('genre', $genre);
        }
        $text = $query->inRandomOrder()->first();

        return $text ? $text->text : 'No text available for the selected language and genre.';
    }
}

resources/js/components/LessonSetup.vue
<template>
    <div class="min-h-screen flex items-center justify-center bg-gray-100">
        <div class="bg-white p-8 rounded shadow-md w-full max-w-md">
            <h2 class="text-2xl font-bold mb-6">Setup Lessons</h2>
            <form @submit.prevent="generateLessons">
                <div class="mb-4">
                    <label class="block text-gray-700">Language</label>
                    <select v-model="form.language" class="w-full p-2 border rounded" required>
                        <option value="en">English</option>
                        <option value="ru">Russian</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label class="block text-gray-700">Number of Lessons</label>
                    <input v-model.number="form.lesson_count" type="number" min="1" class="w-full p-2 border rounded" required />
                </div>
                <button type="submit" class="w-full bg-blue-500 text-white p-2 rounded">Generate Lessons</button>
            </form>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';
import { useRouter } from 'vue-router';
import axios from 'axios';

const router = useRouter();
const form = ref({ language: 'en', lesson_count: 10 });

const generateLessons = async () => {
    try {
        await axios.post('/lessons/generate', form.value);
        router.push(`/lesson/${form.value.language}/1`);
    } catch (error) {
        alert('Failed to generate lessons');
    }
};
</script>
resources/js/components/Lesson.vue<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Lesson {{ lesson.number }}/{{ totalLessons }}</h2>
                <span v-if="isLessonCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <div class="flex flex-row items-stretch space-x-4 mb-4">
                <NewCharacters :new-chars="lesson.new_chars" class="flex items-center justify-center" />
                <Statistics :language :time :speed :errors :progress />
            </div>
            <div class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto bg-gray-50 p-2">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char, 'current-word': isCurrentWord[index], 'space': char === ' ', 'line-break': char === '\n' }">
                        {{ char }}
                    </span>
                </div>
                <textarea
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4 resize-none"
                    ref="input"
                    autofocus
                    :disabled="isLessonCompleted"
                    rows="4"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <div v-if="isLessonCompleted" class="flex justify-center mt-4">
                    <router-link
                        v-if="nextLesson"
                        :to="`/lesson/${language}/${nextLesson.number}`"
                        @click="resetAndLoadNext"
                        class="bg-blue-500 text-white p-2 rounded"
                    >
                        Next Lesson
                    </router-link>
                    <router-link
                        v-else
                        :to="`/test/${language}`"
                        class="bg-green-500 text-white p-2 rounded"
                    >
                        Take Final Test
                    </router-link>
                </div>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import NewCharacters from './NewCharacters.vue';
import { scrollToCurrentChar } from '@/helpers/DomHelper';
import { getCurrentTypingUnit } from '@/helpers/StringHelper';

const route = useRoute();
const language = route.params.language as string;
const lessonNumber = ref(parseInt(route.params.number as string));
const lesson = ref<{ id: number; number: number; new_chars: string }>({ id: 0, number: lessonNumber.value, new_chars: '' });
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLTextAreaElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const lessons = ref<any[]>([]);
const isLessonCompleted = ref(false);
const totalLessons = ref(0);

const nextLesson = computed(() => lessons.value.find(l => l.number === lessonNumber.value + 1));
const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const resetState = () => {
    text.value = '';
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isLessonCompleted.value = false;
};

const fetchLesson = async () => {
    const [lessonsRes, textRes] = await Promise.all([
        axios.get(`/lessons/${language}`),
        axios.get(`/lessons/${language}/${lessonNumber.value}/text`),
    ]);

    lessons.value = lessonsRes.data;
    totalLessons.value = lessonsRes.data.length;
    lesson.value = lessonsRes.data.find((l: any) => l.number === lessonNumber.value);
    text.value = textRes.data.text;
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isLessonCompleted.value = true;
        await axios.post('/lessons/progress', {
            lesson_id: lesson.value.id,
            language: language,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

const resetAndLoadNext = async () => {
    if (!isLessonCompleted.value) return;
    lessonNumber.value++;
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
};

onMounted(async () => {
    resetState();
    await fetchLesson();
    if (input.value) {
        input.value.focus();
    }
});

const currentTypingUnit = computed(() => getCurrentTypingUnit(text.value, typed.value.length));

const isCurrentWord = computed(() => {
    const range = currentTypingUnit.value;
    if (!range) return Array(text.value.length).fill(false);
    const arr = Array(text.value.length).fill(false);
    for (let i = range.start; i <= range.end; i++) {
        arr[i] = true;
    }
    return arr;
});
</script>
resources/js/components/FinalTestSetup.vue
<template>
    <div class="w-1/2 mx-auto my-4 border border-opacity-50 rounded-lg p-4">
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold">Genre (optional)</label>
            <select v-model="genre" class="p-2 border rounded w-full text-sm">
                <option value="">None</option>
                <option value="fiction">Fiction</option>
                <option value="non-fiction">Non-fiction</option>
                <option value="poetry">Poetry</option>
            </select>
        </div>
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold">Upload Text (optional)</label>
            <input type="file" accept=".txt" @change="uploadFile" class="p-2 border rounded w-full text-sm" />
        </div>
        <button @click="$emit('start-test')" class="bg-blue-500 text-white p-2 rounded w-full text-sm">Start Test</button>
    </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';

const genre = ref('');
defineProps<{
    uploadFile: (event: Event) => void;
}>();
defineEmits<{
    (e: 'start-test'): void;
}>();
</script>
resources/js/components/FinalTest.vue
<template>
    <div class="min-h-screen bg-gray-100 p-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded shadow-md">
            <div class="relative flex items-center mb-4">
                <h2 class="text-2xl font-bold">Final Test</h2>
                <span v-if="isTestCompleted" class="absolute left-1/2 transform -translate-x-1/2 text-green-500 text-3xl font-bold">Completed!</span>
            </div>
            <FinalTestSetup v-if="!text" :upload-file="uploadFile" @start-test="fetchText" />
            <Statistics v-if="text" :language="language" :time="time" :speed="speed" :errors="errors" :progress="progress" />
            <div v-if="text" class="mt-4">
                <div ref="textContainer" class="text-lg font-mono break-words whitespace-pre-wrap h-28 overflow-y-auto bg-gray-50 p-2">
                    <span v-for="(char, index) in text" :key="index" :class="{ 'error-char': typed[index] && typed[index] !== char, 'current-word': isCurrentWord[index], 'space': char === ' ', 'line-break': char === '\n' }">
                        {{ char }}
                    </span>
                </div>
                <textarea
                    v-model="typed"
                    @input="handleInput"
                    class="w-full p-2 border rounded mt-4 resize-none"
                    ref="input"
                    :disabled="isTestCompleted"
                    autofocus
                    rows="4"
                />
                <VirtualKeyboard :language="language as 'en' | 'ru'" :typed="typed" :text="text" />
                <div v-if="isTestCompleted" class="flex justify-center mt-2">
                    <router-link to="/" class="bg-blue-500 text-white p-2 rounded">Back to Home</router-link>
                </div>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>
import { ref, computed, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import axios from 'axios';
import VirtualKeyboard from './VirtualKeyboard.vue';
import Statistics from './Statistics.vue';
import FinalTestSetup from './FinalTestSetup.vue';
import { scrollToCurrentChar } from '@/helpers/DomHelper';
import { getCurrentTypingUnit } from '@/helpers/StringHelper';

const route = useRoute();
const language = ref(route.params.language as string);
const genre = ref('');
const text = ref('');
const typed = ref('');
const startTime = ref(0);
const time = ref(0);
const errors = ref(0);
const speed = ref(0);
const input = ref<HTMLTextAreaElement | null>(null);
const textContainer = ref<HTMLElement | null>(null);
const isTestCompleted = ref(false);

const progress = computed(() => text.value.length ? Math.round((typed.value.length / text.value.length) * 100) : 0);

const fetchText = async () => {
    const response = await axios.get('/test/text', { params: { language: language.value, genre: genre.value } });
    text.value = response.data.text;
    typed.value = '';
    startTime.value = 0;
    time.value = 0;
    errors.value = 0;
    speed.value = 0;
    isTestCompleted.value = false;
};

const uploadFile = async (event: Event) => {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('language', language.value);
        await axios.post('/test/upload', formData);
        await fetchText();
    }
};

const handleInput = async () => {
    if (!startTime.value) {
        startTime.value = Date.now();
    }

    if (typed.value.length >= text.value.length) {
        typed.value = typed.value.slice(0, text.value.length);
        isTestCompleted.value = true;
        await axios.post('/test/result', {
            language: language.value,
            time_seconds: time.value,
            speed_wpm: speed.value,
            errors: errors.value,
        });
        return;
    }

    const typedChars = typed.value.split('');
    let errorCount = 0;
    for (let i = 0; i < typedChars.length; i++) {
        if (typedChars[i] !== text.value[i]) {
            errorCount++;
        }
    }
    errors.value = errorCount;

    time.value = Math.round((Date.now() - startTime.value) / 1000);
    const words = typed.value.length / 5;
    speed.value = time.value > 0 ? Math.round((words / time.value) * 60) : 0;

    scrollToCurrentChar(textContainer.value, typed.value.length);
};

onMounted(() => {
    if (input.value) {
        input.value.focus();
    }
});

const currentTypingUnit = computed(() => getCurrentTypingUnit(text.value, typed.value.length));

const isCurrentWord = computed(() => {
    const range = currentTypingUnit.value;
    if (!range) return Array(text.value.length).fill(false);
    const arr = Array(text.value.length).fill(false);
    for (let i = range.start; i <= range.end; i++) {
        arr[i] = true;
    }
    return arr;
});
</script>
Необходимо изменить приоритет источников получения текста для финального теста. Сначала нужно определить, загрузил ли пользователь файл именно при текущей генерации теста, а не когда-то давно в прошлом. Если он загрузил файл при текущей генерации теста, то текст для теста будем получать из загруженного файла, это высший приоритет. А если пользователь не загрузил файл именно в этой генерации теста, то сначала попробуем получить текст теста по api grok. Если удалось получить текст через api grok, то будем использовать этот текст для теста. А если не удалось загрузить текст по api grok, то уже в самую последнюю очередь будем загружать текст для теста из базы данных, это низший приоритет. Если для выполнения задачи тебе понадобятся другие данные, скажи мне об том, я предоставлю дополнительную контекстную информацию. Нужно учесть, что для генерации текста теста используется REST API, поэтому вариант с хранением информации о том, что пользователь загрузил файл при текущей генерации теста, в сессии не подходит для данного случая. Все запросы должны быть без сохранения состояния. Минимальные изменения, только необходимые для выполнения задачи, остальной код должен быть неизменным. Код не должен содержать новых комментариев. Выведи обновленный код только тех файлов, которые были изменены.




Для выполнения задачи необходимо изменить логику в TestService.php, чтобы приоритет источников текста для финального теста соответствовал следующим правилам:

Высший приоритет: Текст из файла, загруженного пользователем при текущей генерации теста. Для определения, что файл загружен именно в текущей генерации, будем использовать временную метку файла и сравнивать её с моментом запроса текста теста.
Средний приоритет: Текст, полученный через API Grok, если пользователь не загрузил файл в текущей генерации.
Низший приоритет: Текст из базы данных, если не удалось получить текст через API Grok.
Поскольку сессии использовать нельзя, временная метка файла будет служить индикатором "текущей генерации". Если файл был загружен недавно (например, в последние 5 минут), будем считать его приоритетным. Это позволит сохранить stateless-подход, так как мы полагаемся только на метаданные файла.

Изменения вносятся только в файл app/Services/TestService.php. Остальной код остается неизменным.

Обновленный код: app/Services/TestService.php
php

Копировать
<?php

namespace App\Services;

use App\Models\TestText;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;

class TestService
{
    public function getTestText(string $language, ?string $genre = null, int $userId): string
    {
        $filePath = "uploads/test_{$userId}_{$language}.txt";
        $userFile = Storage::disk('public')->exists($filePath)
            ? Storage::disk('public')->get($filePath)
            : null;

        if ($userFile && Storage::disk('public')->lastModified($filePath) >= now()->subMinutes(5)->timestamp) {
            return $userFile;
        }

        if (config('services.grok.key') && $genre) {
            try {
                $response = Http::withHeaders([
                    'Authorization' => 'Bearer ' . config('services.grok.key'),
                ])->post('https://api.x.ai/v1/generate', [
                    'prompt' => "Generate a 500-word text in $language for typing practice in the $genre genre.",
                ]);

                if ($response->successful()) {
                    return $response->json()['text'];
                }
            } catch (\Exception $e) {
                // Fallback to database text
            }
        }

        $query = TestText::where('language', $language);
        if ($genre) {
            $query->where('genre', $genre);
        }
        $text = $query->inRandomOrder()->first();

        return $text ? $text->text : 'No text available for the selected language and genre.';
    }
}
Объяснение изменений
Проверка загруженного файла:
Добавлена проверка временной метки файла с помощью Storage::disk('public')->lastModified($filePath). Если файл был изменён (загружен) в последние 5 минут (now()->subMinutes(5)->timestamp), он считается загруженным в текущей генерации и возвращается как текст теста.
Это обеспечивает stateless-подход, так как информация о "текущей генерации" основана на метаданных файла, а не на сессии.
Сохранение приоритетов:
Если файл не был загружен недавно (или отсутствует), код переходит к попытке получения текста через API Grok, как было в исходной версии.
Если API Grok недоступен или не возвращает текст, используется текст из базы данных, как указано в исходной логике.
Минимальные изменения:
Изменена только логика проверки файла в начале метода getTestText. Остальная часть метода осталась нетронутой, чтобы сохранить исходное поведение для случаев, когда файл не приоритетен.
Stateless-подход:
Временной порог в 5 минут выбран как разумный интервал для определения "текущей генерации" без необходимости хранить состояние. Это значение можно настроить в будущем, если потребуется, но оно достаточно для типичного сценария использования.
Если потребуются дополнительные данные (например, структура модели TestText или конфигурация хранилища), пожалуйста, предоставьте их. Однако текущих данных достаточно для реализации задачи с минимальными изменениями.






Чем я могу помочь?


DeepSearch


Think

Grok 3
